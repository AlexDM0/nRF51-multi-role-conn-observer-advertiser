// Create your own functions here (see CMSIS_mu.ini and
// http://www.keil.com/support/man/docs/uv4/uv4_debug_functions.htm

// Just map APB Peripherals as normal memory
MAP 0xF0000FE0, 0xF0000FF0 READ WRITE
MAP 0x40000000, 0x40080000 READ WRITE
MAP 0x50000000, 0x50080000 READ WRITE 
MAP 0x10000000, 0x10000100 READ WRITE  // For NRF_FICR use in ble_flash module
MAP 0x4001E000, 0x4001E100 READ WRITE  // For NRF_NVMC register

MAP 0x0003FC00, 0x0003FFFF READ WRITE  // This is where the ble_flash module will read and write bond info.
                                       // 1024 bytes of space = 1 flash page.
                                       // Address start from DEF_FLASH_PAGE_BOND * DEF_CODEPAGESIZE 
MAP 0x0003F400, 0x0003F7FF READ WRITE  // This is where the ble_flash module will read and write sys attributes.
                                       // 1024 bytes of space = 1 flash page.
                                       // Address start from DEF_FLASH_PAGE_BOND * DEF_CODEPAGESIZE .                                       
MAP 0x00014000, 0x0003EFFF READ WRITE  // This this flash area used for the bootloader when updating an image.
                                       // 1024 bytes of space = 1 flash page.
                                       // Address start from CLENR0.                                       

 
// Define the names of registers here, for use in .ini files
DEFINE LONG STX0 // serial port
STX0 = 0x40005008
DEFINE LONG NRF_UART0_TXD
NRF_UART0_TXD = 0x4000251C
DEFINE LONG NRF_UART0_EVENTS_TXDREADY
NRF_UART0_EVENTS_TXDREADY = 0x4000211C
DEFINE LONG CM_OSC32KSTARTED
CM_OSC32KSTARTED = 0x4000D104
DEFINE LONG NRF_GPIO_OUTCLR
NRF_GPIO_OUTCLR = 0x5000050C
DEFINE LONG NRF_GPIO_OUTSET
NRF_GPIO_OUTSET = 0x50000508
DEFINE LONG NRF_GPIO_OUT
NRF_GPIO_OUT = 0x50000504
DEFINE LONG FICR_PAGE_SIZE
FICR_PAGE_SIZE = 0x10000010  // Location of NRF_FICR->CODEPAGESIZE
DEFINE LONG NRF_NVMC_READY 
NRF_NVMC_READY = 0x4001E400  // Location of NRF_NVMC->READY
DEFINE LONG NRF_NVMC_CONFIG
NRF_NVMC_CONFIG = 0x4001E504 // Location of NRF_NVMC->CONFIG
DEFINE LONG NRF_NVMC_ERASEPAGE
NRF_NVMC_ERASEPAGE = 0x4001E508 // Location of NRF_NVMC->ERASEPAGE

// FakeSerial reads the address of the serial port register (which was mapped
// to normal memory above) and prints the characters. They will end up wherever
// LOG points to.
//
// Example use:
//   FakeSerial();
//   LOG>cunit.log
//   G,cu_exit
//   LOG OFF
signal void FakeSerialSTX()
{
  unsigned char val;

  while(1)
  {
    wwatch(STX0);
    val = _RBYTE(STX0);
    printf("%c", val);
  }
}

signal void FakeSerial()
{
  while(1)
  {
    wwatch(NRF_UART0_TXD);
    printf("%c", _RBYTE(NRF_UART0_TXD));
    _WDWORD(NRF_UART0_EVENTS_TXDREADY, 1);  // We sent the character, signal event
  }
}

signal void NRF_GPIO_OUTCLR()
{
  while(1)
  {
    wwatch(NRF_GPIO_OUTCLR);
    _WDWORD(NRF_GPIO_OUT, _RDWORD(NRF_GPIO_OUT) & ~_RDWORD(NRF_GPIO_OUTCLR));
    _WDWORD(NRF_GPIO_OUTCLR, 0);
  }
}

signal void NRF_GPIO_OUTSET()
{
  while(1)
  {
    wwatch(NRF_GPIO_OUTSET);
    _WDWORD(NRF_GPIO_OUT, _RDWORD(NRF_GPIO_OUT) | _RDWORD(NRF_GPIO_OUTSET));
    _WDWORD(NRF_GPIO_OUTSET, 0);
  }
}


signal void NRF_NVMC_ERASEPAGE()
{
  while(1)
  {
    wwatch(NRF_NVMC_ERASEPAGE);
    memset((_RDWORD(NRF_NVMC_ERASEPAGE)), _RDWORD(FICR_PAGE_SIZE), 0xff);
    _WDWORD(NRF_NVMC_READY, 0x1);
  }
}

signal void NRF_NVMC_CONFIG()
{
  while(1)
  {
    wwatch(NRF_NVMC_CONFIG);
    _WDWORD(NRF_NVMC_READY, 0x1);
  }
}

FakeSerialSTX();
FakeSerial();
NRF_GPIO_OUTCLR();
NRF_GPIO_OUTSET();
NRF_NVMC_ERASEPAGE();
NRF_NVMC_CONFIG();

_WDWORD(FICR_PAGE_SIZE, 1024);

LOG>cunit.log
G,cu_exit
LOG OFF
LOG>coverage.log
COVERAGE
LOG OFF
EXIT